### 第1章: 基礎編 (APIの基本操作) (1-30)

**環境構築と基本**

1.  **ノック1: FastAPIとUvicornのインストール**
    * 課題: FastAPI と ASGI サーバーである Uvicorn をインストールしてください。
2.  **ノック2: Hello World API**
    * 課題: ルートパス (`/`) に GET リクエストを送ると `{"message": "Hello World"}` という JSON を返す最小限の FastAPI アプリケーションを作成し、Uvicorn で実行してください。
3.  **ノック3: パスパラメータ**
    * 課題: `/items/{item_id}` というパスで、`item_id` をパスパラメータとして受け取り、`{"item_id": item_id}` という JSON を返す API を作成してください。`item_id` は整数型としてください。
4.  **ノック4: 型ヒント付きパスパラメータ**
    * 課題: ノック3の API で、`item_id` が整数であることを型ヒントで明示してください。FastAPI が自動でバリデーションを行うことを確認してください (例: 文字列を渡してエラーレスポンスを確認)。
5.  **ノック5: クエリパラメータ**
    * 課題: `/items/` というパスで、オプションのクエリパラメータ `skip` (デフォルト値0) と `limit` (デフォルト値10) を受け取り、`{"skip": skip, "limit": limit}` という JSON を返す API を作成してください。
6.  **ノック6: 必須クエリパラメータ**
    * 課題: `/users/` というパスで、必須のクエリパラメータ `user_id` (文字列型) を受け取り、`{"user_id": user_id}` という JSON を返す API を作成してください。`user_id` が指定されない場合にエラーとなることを確認してください。
7.  **ノック7: Pydanticによるリクエストボディ**
    * 課題: `name` (文字列) と `price` (浮動小数点数) という属性を持つ Pydantic モデル `Item` を定義し、`/items/` への POST リクエストでこの `Item` モデルを受け取り、受け取った内容をそのまま JSON で返す API を作成してください。
8.  **ノック8: リクエストボディとパス・クエリパラメータの組み合わせ**
    * 課題: `/items/{item_id}` への PUT リクエストで、パスパラメータ `item_id` (整数)、クエリパラメータ `q` (文字列、任意)、リクエストボディ `Item` (ノック7で定義) を受け取り、`{"item_id": item_id, "q": q, "item_name": item.name, "item_price": item.price}` という JSON を返す API を作成してください。
9.  **ノック9: Pydanticモデルのネスト**
    * 課題: `name` (文字列) 属性を持つ `User` モデルと、`description` (文字列、任意) と `owner` (`User` モデル) 属性を持つ `Item` モデルを定義してください。`/items_with_owner/` への POST リクエストでこのネストされた `Item` モデルを受け取り、内容を返す API を作成してください。
10. **ノック10: レスポンスモデル**
    * 課題: `/users/me` というパスで、`username` と `email` を含む Pydantic モデル `UserOut` を定義し、内部的にはパスワード情報なども持つが、レスポンスとしては `UserOut` モデルで定義されたフィールドのみを返す API を作成してください (`response_model` パラメータを使用)。

**データ形式とバリデーション**

11. **ノック11: Pydanticによる高度なバリデーション (Field)**
    * 課題: `Item` モデルの `name` に最小長3、最大長50の制約を、`price` に0より大きいという制約を `Field` を使って追加してください。制約に違反するリクエストでエラーが発生することを確認してください。
12. **ノック12: Pydanticのデフォルト値と任意フィールド**
    * 課題: `Item` モデルに `description` (文字列、任意、デフォルト値なし) と `tax` (浮動小数点数、任意、デフォルト値0.1) を追加してください。リクエストボディでこれらのフィールドが省略可能であること、デフォルト値が適用されることを確認してください。
13. **ノック13: パスパラメータのバリデーション (Path)**
    * 課題: `/files/{file_path:path}` というパスで、パスパラメータ `file_path` を受け取る API を作成してください。また、別のパス `/items_validated/{item_id}` で、`item_id` が 1 以上 1000 以下であることを `Path` を使ってバリデーションしてください。
14. **ノック14: クエリパラメータのバリデーション (Query)**
    * 課題: `/search/` というパスで、クエリパラメータ `q` (文字列、必須、最小長3)、`max_results` (整数、任意、1以上100以下) を `Query` を使って定義し、バリデーションを行う API を作成してください。
15. **ノック15: 複数のボディパラメータ**
    * 課題: `/order/` への POST リクエストで、`Item` モデルと `User` モデルの両方をリクエストボディとして受け取る API を作成してください (`Body(...)` を使用)。
16. **ノック16: ボディパラメータの埋め込み (`embed`)**
    * 課題: ノック7の API で、リクエストボディを `{"item": {"name": "Foo", "price": 10.5}}` のようにキー `item` でラップする必要があるように変更してください (`Body(..., embed=True)` を使用)。
17. **ノック17: ステータスコードの指定**
    * 課題: `/items/` への POST リクエストが成功した場合、デフォルトの 200 OK ではなく 201 Created ステータスコードを返すように API を変更してください (`status_code` パラメータを使用)。
18. **ノック18: エラーハンドリング (HTTPException)**
    * 課題: `/items/{item_id}` で、存在しない `item_id` が指定された場合に、`HTTPException` を発生させ、404 Not Found ステータスコードとカスタムエラーメッセージ `{"detail": "Item not found"}` を返すように API を作成してください。
19. **ノック19: カスタムヘッダーの送信**
    * 課題: `/custom-header/` への GET リクエストに対して、`X-Custom-Header: my-custom-value` というカスタムヘッダーを含むレスポンスを返す API を作成してください (`Response` オブジェクトを使用)。
20. **ノック20: フォームデータ**
    * 課題: `/login/` への POST リクエストで、`username` と `password` をフォームデータとして受け取る API を作成してください (`Form(...)` を使用)。

**ファイル、ルーティング、静的ファイル**

21. **ノック21: ファイルアップロード (単一ファイル)**
    * 課題: `/uploadfile/` への POST リクエストで、単一のファイルをアップロードし、ファイル名と Content-Type を返す API を作成してください (`UploadFile`, `File(...)` を使用)。
22. **ノック22: ファイルアップロード (複数ファイル)**
    * 課題: `/uploadfiles/` への POST リクエストで、複数のファイルをアップロードし、それぞれのファイル名と Content-Type のリストを返す API を作成してください。
23. **ノック23: ファイルアップロード (ファイルサイズ制限)**
    * 課題: ノック21の API で、アップロードできるファイルサイズを 1MB に制限してください (ミドルウェアまたは依存性注入を使用)。
24. **ノック24: APIRouterによるルーティング分割**
    * 課題: `items` 関連のパス操作 (`/items/`, `/items/{item_id}`) と `users` 関連のパス操作 (`/users/me`) を、それぞれ別のファイル (例: `routers/items.py`, `routers/users.py`) に `APIRouter` を使って定義し、メインのアプリケーション (`main.py`) からインクルードしてください。
25. **ノック25: ルーターのプレフィックスとタグ**
    * 課題: ノック24で作成した `items` ルーターに `/api/v1` というプレフィックスと `items` というタグを、`users` ルーターにも同様にプレフィックスと `users` タグを設定してください。OpenAPI ドキュメントでの表示を確認してください。
26. **ノック26: 静的ファイルの配信**
    * 課題: `static` というディレクトリを作成し、その中に `index.html` ファイルを配置してください。`/static` というパスでこのディレクトリ内の静的ファイルを配信できるように FastAPI アプリケーションを設定してください (`StaticFiles`)。
27. **ノック27: Jinja2テンプレートの使用**
    * 課題: `templates` ディレクトリを作成し、`item.html` という Jinja2 テンプレートを作成してください。`/render/item/{item_id}` というパスで、`item_id` と適当なアイテム情報をテンプレートに渡し、レンダリングされた HTML を返す API を作成してください (`Jinja2Templates`)。
28. **ノック28: OpenAPIドキュメントの基本カスタマイズ**
    * 課題: FastAPI アプリケーションのインスタンス化時に `title`, `description`, `version` パラメータを指定し、OpenAPI ドキュメント (`/docs`) の表示をカスタマイズしてください。
29. **ノック29: パスオペレーションの概要と説明**
    * 課題: 特定のパスオペレーション関数 (`@app.get(...)` など) に `summary` と `description` パラメータを追加し、OpenAPI ドキュメントでの表示を改善してください。
30. **ノック30: レスポンスの説明 (responses)**
    * 課題: ノック18の API で、404 エラーレスポンスに関する説明を `responses` パラメータを使って OpenAPI ドキュメントに追加してください。

---

### 第2章: 中級編 (実践的な機能と連携) (31-70)

**依存性注入とミドルウェア**

31. **ノック31: 依存性注入の基本 (Depends)**
    * 課題: クエリパラメータ `q` (任意) と `skip`, `limit` を受け取る `common_parameters` という依存関数を作成してください。`/items/` と `/users/` の2つのパスオペレーションでこの依存関数を使用し、受け取ったパラメータを返してください。
32. **ノック32: クラスベースの依存性注入**
    * 課題: ノック31の `common_parameters` をクラスとして実装してください (`__init__` でパラメータを受け取る)。
33. **ノック33: 依存性注入のキャッシュ**
    * 課題: 時間のかかる処理（例: `time.sleep(1)`）を行う依存関数を作成し、同じリクエスト内で複数回呼び出された場合に、デフォルトでキャッシュが効いて処理が1回しか実行されないことを確認してください (`use_cache=True` がデフォルト)。キャッシュを無効にする (`use_cache=False`) 場合も試してください。
34. **ノック34: サブ依存性**
    * 課題: 依存関数 A が別の依存関数 B に依存するような構造を作成してください (例: B がユーザー認証を行い、A がそのユーザー情報を使う)。
35. **ノック35: パスオペレーションデコレータ内の依存性 (`dependencies`)**
    * 課題: ルーター全体または特定のパスオペレーションに対して、常に実行される依存性 (例: APIキーの検証) を `dependencies` パラメータを使って設定してください。
36. **ノック36: バックグラウンドタスク (BackgroundTasks)**
    * 課題: `/send-email/` というパスオペレーションで、リクエストを受け取ったらすぐにレスポンスを返し、バックグラウンドで時間がかかるメール送信処理（のシミュレーション）を行うように `BackgroundTasks` を使用してください。
37. **ノック37: カスタムミドルウェア (処理時間計測)**
    * 課題: 全てのリクエストの処理時間を計測し、レスポンスヘッダー `X-Process-Time` に追加するカスタムミドルウェアを作成してください (`@app.middleware("http")`)。
38. **ノック38: CORS (Cross-Origin Resource Sharing) ミドルウェア**
    * 課題: 異なるオリジン (例: `http://localhost:8080`) からの特定のメソッド (GET, POST) とヘッダーを許可するように `CORSMiddleware` を設定してください。

**データベース連携 (非同期 SQLAlchemy 例)**

*注意: 以下のノックでは非同期 SQLAlchemy (asyncpg/aiosqlite ドライバ) の利用を想定しますが、他の ORM (Tortoise ORM, Gino など) や ODM (Motor) でも同様の課題設定が可能です。適宜読み替えてください。*

39. **ノック39: データベース接続設定**
    * 課題: 非同期 SQLAlchemy を使用して、PostgreSQL (または SQLite) データベースへの接続設定を行ってください (例: `DATABASE_URL` の設定)。
40. **ノック40: SQLAlchemy モデル定義**
    * 課題: `id` (主キー), `name` (文字列), `description` (文字列、任意) を持つ `Item` テーブルに対応する SQLAlchemy モデルを定義してください。
41. **ノック41: テーブル作成**
    * 課題: アプリケーション起動時に SQLAlchemy モデルに基づいてデータベーステーブルを作成する処理を追加してください (Alembic 等のマイグレーションツールを使うのが実用的ですが、ここでは単純化します)。
42. **ノック42: 非同期セッションの依存性注入**
    * 課題: 各リクエストで非同期データベースセッションを取得し、リクエスト処理後に自動的にクローズする依存関数 `get_db` を作成してください。
43. **ノック43: データ作成 (Create)**
    * 課題: `/items/` への POST リクエストで `Item` データを受け取り、`get_db` 依存関数を使ってデータベースに新しいアイテムを非同期で作成する API を実装してください。Pydantic モデルを入出力に使用してください。
44. **ノック44: データ読み取り (Read - 単一)**
    * 課題: `/items/{item_id}` への GET リクエストで、指定された ID のアイテムをデータベースから非同期で取得し、返す API を実装してください。見つからない場合は 404 エラーを返してください。
45. **ノック45: データ読み取り (Read - 複数)**
    * 課題: `/items/` への GET リクエストで、`skip` と `limit` クエリパラメータに基づいて複数のアイテムをデータベースから非同期で取得し、リストとして返す API を実装してください。
46. **ノック46: データ更新 (Update)**
    * 課題: `/items/{item_id}` への PUT リクエストで、指定された ID のアイテムをリクエストボディの内容で非同期に更新する API を実装してください。
47. **ノック47: データ削除 (Delete)**
    * 課題: `/items/{item_id}` への DELETE リクエストで、指定された ID のアイテムをデータベースから非同期で削除する API を実装してください。
48. **ノック48: リレーションシップ (単純な例)**
    * 課題: `User` モデル (id, email) を追加し、`Item` モデルに `owner_id` (外部キー) と `owner` (リレーションシップ) を追加してください。アイテム作成時にオーナーを指定できるようにし、アイテム取得時にオーナー情報も（オプションで）取得できるように API を変更してください。
49. **ノック49: トランザクション管理**
    * 課題: 複数のデータベース操作（例: 2つのアイテムを作成）を単一のトランザクション内で実行し、途中でエラーが発生した場合はロールバックされることを確認する API またはテストを作成してください。
50. **ノック50: データベース操作のテスト**
    * 課題: ノック43 (データ作成) の API に対して、テスト用データベースと `TestClient` を使用して、実際にデータが作成されることを確認するテストコードを `pytest` で記述してください。

**認証と認可**

51. **ノック51: パスワードハッシュ化**
    * 課題: `passlib` を使用して、ユーザー登録時やパスワード変更時にパスワードを安全にハッシュ化し、ログイン時にハッシュ化されたパスワードを検証する関数を作成してください。
52. **ノック52: OAuth2 パスワードフロー (トークンエンドポイント)**
    * 課題: `/token` エンドポイントを作成し、フォームデータ (`username`, `password`) を受け取ってユーザーを認証し、成功した場合に JWT アクセストークンを生成して返す OAuth2 パスワードフローを実装してください (`OAuth2PasswordBearer`, `OAuth2PasswordRequestForm`)。
53. **ノック53: JWT トークン生成とデコード**
    * 課題: `python-jose` ライブラリを使用して、ユーザー情報 (例: `sub`=username) を含む JWT アクセストークンを生成し、また受け取ったトークンをデコードして検証する関数を作成してください (秘密鍵、アルゴリズム、有効期限を含む)。
54. **ノック54: 依存性注入による現在のユーザー取得**
    * 課題: `Authorization: Bearer <token>` ヘッダーから JWT トークンを取得・検証し、対応するユーザー情報をデータベース等から取得して返す依存関数 `get_current_user` を作成してください。トークンが無効な場合は `HTTPException` (401 Unauthorized) を発生させてください。
55. **ノック55: 保護されたエンドポイント**
    * 課題: `/users/me` エンドポイントを作成し、`get_current_user` 依存関数を使用して認証されたユーザーのみがアクセスできるようにしてください。認証されたユーザー自身の情報を返してください。
56. **ノック56: ロールベースアクセス制御 (簡単な例)**
    * 課題: `User` モデルに `role` (例: "admin", "user") フィールドを追加してください。特定のパスオペレーション (例: `/admin/`) が "admin" ロールを持つユーザーのみアクセスできるように、`get_current_user` を拡張するか、別の依存関数を作成してチェックしてください。アクセス権がない場合は `HTTPException` (403 Forbidden) を発生させてください。
57. **ノック57: トークンのリフレッシュ (概念)**
    * 課題: アクセストークンとは別に、より有効期間の長いリフレッシュトークンを発行・検証する仕組みについて調査し、リフレッシュトークンを使って新しいアクセストークンを取得するエンドポイント `/refresh_token` の設計案を考えてください (実装は任意)。
58. **ノック58: APIキー認証**
    * 課題: `X-API-Key` ヘッダーで渡される固定の API キーを検証する依存関数を作成し、特定のパスオペレーションに適用してください (`APIKeyHeader`)。

**WebSocket**

59. **ノック59: 基本的なWebSocket接続**
    * 課題: `/ws` パスで WebSocket 接続を受け付け、クライアントからの接続を待ち受けるエンドポイントを作成してください。接続が確立したら `accept()` を呼び出してください。
60. **ノック60: WebSocketでのメッセージ送受信**
    * 課題: ノック59のエンドポイントで、クライアントから受信したメッセージをそのままクライアントに送り返す (エコーする) 処理を実装してください (`receive_text()`, `send_text()`)。クライアントが接続を切断した場合の処理も追加してください。
61. **ノック61: WebSocketでのJSON送受信**
    * 課題: `/ws/json` パスで、クライアントと JSON 形式でメッセージを送受信する WebSocket エンドポイントを作成してください (`receive_json()`, `send_json()`)。
62. **ノック62: WebSocketブロードキャスト (単純な実装)**
    * 課題: 接続中の全クライアントをリストで管理し、あるクライアントからメッセージを受信したら、接続中の他の全クライアントにそのメッセージをブロードキャストする簡単なチャット機能（のようなもの）を実装してください (注意: プロダクションではより堅牢な仕組みが必要です)。
63. **ノック63: WebSocketと依存性注入**
    * 課題: WebSocket エンドポイント内で、クエリパラメータや Cookie から情報を取得する依存性注入を使用してください (例: `/ws/{client_id}` として `client_id` を受け取る)。
64. **ノック64: WebSocketでの認証**
    * 課題: WebSocket 接続時にトークン (例: クエリパラメータや Cookie) を検証し、認証されたユーザーのみ接続を許可する処理を実装してください。

**テストと設定**

65. **ノック65: TestClientの基本**
    * 課題: ノック2 の Hello World API に対して、`TestClient` を使用して GET リクエストを送信し、ステータスコードが 200 で、レスポンスボディが期待通りであることを確認するテストを `pytest` で記述してください。
66. **ノック66: パスパラメータとクエリパラメータのテスト**
    * 課題: ノック3, 5 の API に対して、`TestClient` を使用してパスパラメータやクエリパラメータを指定したリクエストを送信し、レスポンスを検証するテストを記述してください。
67. **ノック67: リクエストボディのテスト**
    * 課題: ノック7 の API に対して、`TestClient` を使用して JSON リクエストボディを含む POST リクエストを送信し、レスポンスを検証するテストを記述してください。
68. **ノック68: 認証が必要なエンドポイントのテスト**
    * 課題: ノック55 の `/users/me` エンドポイントに対して、`TestClient` を使用して `Authorization` ヘッダーに有効なトークン（またはテスト用のダミートークン）を設定してリクエストを送信し、成功するケースと、トークンがない場合に 401 エラーになるケースのテストを記述してください。依存関係の上書き (`dependency_overrides`) が役立ちます。
69. **ノック69: Pydantic Settingsによる設定管理**
    * 課題: `pydantic-settings` を使用して、アプリケーションの設定 (例: `DATABASE_URL`, `SECRET_KEY`, `ALGORITHM`) を環境変数や `.env` ファイルから読み込む `Settings` クラスを作成し、アプリケーション内で利用してください。
70. **ノック70: 異なる環境用の設定**
    * 課題: 開発環境 (`development`) と本番環境 (`production`) で異なる設定値 (例: デバッグモードの有効/無効) を読み込めるように、ノック69の `Settings` クラスまたは設定ファイルの読み込み方法を工夫してください (例: `APP_ENV` 環境変数を使用)。

---

### 第3章: 応用編 (パフォーマンス、設計、デプロイ) (71-100)

**パフォーマンスと非同期処理**

71. **ノック71: Gzipミドルウェア**
    * 課題: レスポンスを Gzip 圧縮して転送量を削減するために `GZipMiddleware` を追加してください。
72. **ノック72: `response_model` の最適化 (`response_model_exclude_unset`)**
    * 課題: Pydantic モデルのデフォルト値を持つフィールドがレスポンスに含まれないように、`response_model_exclude_unset=True` をパスオペレーションデコレータに設定し、レスポンスサイズの変化を確認してください。
73. **ノック73: 非同期処理の基本 (async/await)**
    * 課題: 時間のかかる I/O バウンドな処理 (例: 外部 API へのリクエスト) を `httpx` などの非同期 HTTP クライアントを使って `async def` 関数内で `await` を使って実行し、その間も他のリクエストをブロックしないことを確認してください (簡単な負荷テストツールなどで)。
74. **ノック74: `asyncio.gather` による並列処理**
    * 課題: 複数の独立した非同期 I/O 処理 (例: 複数の外部 API を呼び出す) を `asyncio.gather` を使って並列実行し、全体の処理時間を短縮する API を作成してください。
75. **ノック75: CPU バウンド処理の分離 (`run_in_executor`)**
    * 課題: 時間のかかる CPU バウンドな計算処理 (例: 大きなデータの複雑な計算) を、`FastAPI` の `run_in_threadpool` (内部的に `loop.run_in_executor` を使用) を使って別スレッドで実行し、イベントループをブロックしないようにしてください。
76. **ノック76: パフォーマンスプロファイリング (簡単な例)**
    * 課題: `pyinstrument` や `cProfile` などのツールを使用して、特定の API エンドポイントのパフォーマンスボトルネックを特定する方法を調査・試行してください。

**設計とアーキテクチャ**

77. **ノック77: レイヤードアーキテクチャ (概念)**
    * 課題: アプリケーションをプレゼンテーション層 (API ルーター)、サービス層 (ビジネスロジック)、リポジトリ層 (データアクセス) に分割する基本的なレイヤードアーキテクチャの構造を、ディレクトリ構成と依存関係の観点から設計してください。
78. **ノック78: サービス層の実装**
    * 課題: ノック77の設計に基づき、アイテムに関するビジネスロジック (例: 特定の条件下でのみアイテム作成を許可する) を担当するサービス関数またはサービスクラスを作成し、API ルーターから呼び出すように実装してください。依存性注入を利用してサービス層を API 層に注入します。
79. **ノック79: リポジトリパターンの実装**
    * 課題: ノック77の設計に基づき、データベース操作 (CRUD) を抽象化するリポジトリクラス (例: `ItemRepository`) を作成してください。サービス層はこのリポジトリを通じてデータアクセスを行います。依存性注入を利用してリポジトリ層をサービス層に注入します。
80. **ノック80: ドメインモデルとPydantic**
    * 課題: アプリケーションの中心となるドメインエンティティ (例: `Item`, `User`) を Pydantic モデルで定義し、バリデーションロジックの一部をモデル内に含めることを検討してください。API の入出力用モデル (DTO) とドメインモデルを区別する必要性についても考察してください。
81. **ノック81: エラーハンドリングの統一 (`@app.exception_handler`)**
    * 課題: カスタム例外クラス (例: `ItemNotFoundError`) を定義し、`@app.exception_handler` を使ってこの例外が発生した場合に特定の HTTP ステータスコードとエラーレスポンス形式でクライアントに返すグローバルな例外ハンドラを実装してください。
82. **ノック82: イベント駆動 (概念と簡単な例)**
    * 課題: アイテムが作成されたときに `ItemCreated` のようなイベントを発行し、それを別のコンポーネント（例: バックグラウンドタスクや別のサービス）が購読して処理する（例: ログ記録、通知送信）というイベント駆動の仕組みを、`BackgroundTasks` や外部メッセージキュー (概念) を使って実装するアイデアを考えてください。

**デプロイと運用**

83. **ノック83: Uvicornのワーカー数調整**
    * 課題: Uvicorn を複数のワーカープロセスで起動する方法 (`--workers` オプション) を試し、CPU コア数に応じた適切なワーカー数を設定することの重要性を理解してください。
84. **ノック84: Gunicornとの連携**
    * 課題: プロダクション環境で推奨されることが多い Gunicorn と `uvicorn.workers.UvicornWorker` を組み合わせて FastAPI アプリケーションを実行する方法を試し、設定オプション (ワーカー数、タイムアウトなど) を調べてください。
85. **ノック85: Dockerfileの作成**
    * 課題: FastAPI アプリケーション (依存関係を含む) をコンテナ化するための基本的な `Dockerfile` を作成してください。Python イメージをベースとし、依存関係のインストール、コードのコピー、Uvicorn の起動コマンドを含めます。
86. **ノック86: マルチステージビルド (Docker)**
    * 課題: プロダクション用の Docker イメージサイズを削減するために、ビルド用のステージと実行用のステージを分けるマルチステージビルドを用いた `Dockerfile` に改良してください。
87. **ノック87: Docker Composeによる複数コンテナ管理**
    * 課題: FastAPI アプリケーションコンテナと、それが依存するデータベースコンテナ (例: PostgreSQL) を `docker-compose.yml` で定義し、`docker-compose up` で同時に起動できるようにしてください。環境変数を使ってコンテナ間の接続情報を渡してください。
88. **ノック88: Nginxによるリバースプロキシ設定**
    * 課題: Gunicorn/Uvicorn の前段に Nginx をリバースプロキシとして配置する基本的な設定ファイルを作成してください。静的ファイルの配信やリクエストの転送設定を含みます。HTTPS 化 (Let's Encrypt) の考慮点についても調査してください。
89. **ノック89: ヘルスチェックエンドポイント**
    * 課題: アプリケーションが正常に動作しているかを確認するための簡単なヘルスチェックエンドポイント (`/health`) を作成してください (例: `{"status": "ok"}` を返す)。コンテナオーケストレーションツールなどで利用されます。
90. **ノック90: ロギング設定**
    * 課題: Python 標準の `logging` モジュールまたは `loguru` などのライブラリを使用して、FastAPI アプリケーションのログ (リクエスト情報、エラー、デバッグ情報など) を設定し、ファイルまたは標準出力に出力されるようにしてください。ログレベルやフォーマットを設定してください。
91. **ノック91: 構造化ロギング**
    * 課題: ログを JSON 形式などの構造化された形式で出力するように設定してください。これにより、ログ収集・分析ツール (例: Elasticsearch, Datadog) での処理が容易になります。
92. **ノック92: モニタリング (Prometheus連携の準備)**
    * 課題: `starlette-prometheus` などのライブラリを使用して、リクエスト数、レイテンシ、エラー数などの基本的なメトリクスを Prometheus が収集できる形式 (`/metrics` エンドポイント) で公開できるようにアプリケーションを設定してください。
93. **ノック93: 分散トレーシング (概念)**
    * 課題: OpenTelemetry などの分散トレーシングの仕組みを FastAPI に導入する方法について調査してください。マイクロサービス環境などでリクエストが複数のサービスを横断する場合の追跡に役立ちます。

**高度なトピックとエコシステム**

94. **ノック94: GraphQL (Strawberry)**
    * 課題: `strawberry-graphql[fastapi]` を使用して、既存の `Item` モデルに対する基本的な GraphQL クエリ (全件取得、ID指定取得) とミューテーション (作成) を実装した GraphQL エンドポイント (`/graphql`) を FastAPI アプリケーションに追加してください。
95. **ノック95: gRPC ゲートウェイ (概念)**
    * 課題: FastAPI を gRPC サービスの HTTP/JSON ゲートウェイとして機能させる方法について調査してください。gRPC の知識が必要になります。
96. **ノック96: 高度なPydantic (カスタムバリデータ)**
    * 課題: Pydantic モデルで、フィールド間の依存関係を持つような複雑なバリデーションルールを `@validator` デコレータを使って実装してください (例: `start_date` は `end_date` より前でなければならない)。
97. **ノック97: 高度なPydantic (カスタムデータ型)**
    * 課題: 特定のフォーマットを持つカスタムデータ型 (例: 電話番号、郵便番号) を Pydantic で定義し、バリデーションできるようにしてください (`__get_validators__`)。
98. **ノック98: レートリミット**
    * 課題: `slowapi` などのライブラリを使用して、特定の API エンドポイントまたは全エンドポイントに対して、IP アドレスごとやユーザーごとにリクエスト回数制限 (例: 1分間に100回まで) を実装してください。
99. **ノック99: セキュリティヘッダー**
    * 課題: ミドルウェアを使用して、`X-Content-Type-Options`, `X-Frame-Options`, `Strict-Transport-Security` などの推奨されるセキュリティ関連 HTTP ヘッダーをレスポンスに追加してください。
100. **ノック100: サーバーレスデプロイ (概念)**
    * 課題: FastAPI アプリケーションを AWS Lambda + API Gateway, Google Cloud Run, Azure Functions などのサーバーレスプラットフォームにデプロイする方法について調査し、`Mangum` などのアダプタライブラリの役割を理解してください。
